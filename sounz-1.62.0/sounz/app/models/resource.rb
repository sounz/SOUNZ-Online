class Resource < ActiveRecord::Base
  set_primary_key 'resource_id'
  
  include FrbrHelper
  include FrbrMethodsResource
  include FacetHelper
  
  

   # for searching resources
   acts_as_solr  :fields =>[
          :frbr_ui_desc_for_solr,
          :title_for_solr,
          {:title_as_string_for_solr => :string},
          :series_title_for_solr,
          :general_note_for_solr,
          :internal_note_for_solr,
          :dedication_note_for_solr,
          :publisher_note_for_solr,
          :isbn_for_solr,
          :ismn_for_solr,
          :isrc_for_solr,
          :publication_year_for_solr,
          :imprint_for_solr, 
          :mw_code_for_solr,
          :code_for_solr,
          :status_for_solr,
          :available_as_top_level_facet_for_solr,
          :author_note_for_solr,
          {:duration_for_solr  => :integer},
          :genres_for_solr,
          :influences_for_solr,
          :themes_for_solr,
          :has_related_resources_for_solr,
          :related_resource_type_ids_for_solr,
          :can_be_bought_for_solr,
          :can_be_loaned_for_solr,
          :can_be_hired_for_solr,
          :downloadable_for_solr,
          :quicklink_format_for_solr,
          :available_as_resource_types_facet_for_solr,
          :item_type_ids_for_solr,
          :type_for_solr,
          :freight_code_for_solr,
          {:authors_cvs_as_string_for_solr => :string},
          {:created_at_for_solr => :string}
          #:available_for_hire_for_solr,
          #:available_for_sale_for_solr
          #
  ]
      
  belongs_to :status
  
  
  belongs_to :login_updated_by, 
            :class_name => 'Login',
            :foreign_key => :updated_by
            

            
  #relationship to format
  belongs_to :format

  #relationship to resource type
  belongs_to :resource_type
  
  has_many :resource_relationships
  has_many :relationships, :through => :resource_relationships, 
      :select => "resource_relationships.relationship_type_id, relationships.*"
  
  
  has_many :resource_attachments
  has_many :media_items, :through => :resource_attachments
  
  has_many :items, :dependent => :destroy
  
  has_many :resource_access_rights
  
  validates_presence_of :resource_title
  
  validates_length_of :resource_title, :in => 2..100,
  :allow_nil => true,
  :message => "is not between 2 and 100 chars",
  :if => ModelHelper.only_check_if_not_empty( :resource_title)
  
  validates_presence_of :resource_code
  

  
  validates_length_of :series_title, :in => 2..100,
  :allow_nil => true,
  :message => "is not between 2 and 100 chars",
  :if => ModelHelper.only_check_if_not_empty( :series_title)
  
  #Updated by relationship 
  validates_presence_of  :status, :format, :resource_type
  validates_associated  :status, :format, :resource_type
  
   validates_numericality_of :publication_year,
    :if => ModelHelper.only_check_if_not_empty( :publication_year)
  
  validates_length_of :resource_title, :in => 2..100,
  :allow_nil => true,
  :message => "is not between 2 and 100 chars",
  :if => ModelHelper.only_check_if_not_empty( :resource_title)
  
  validate :sounzmedia_format
  
  validates_format_of :duration, 
                      :if => Proc.new {|model| ( model.duration != nil) },
                      :with => DURATION_REGEX,
                      :message=> "must be of the format |number|:|00 to 59|:|00 to 59|"
  
  
  # for HTML interface
  acts_as_dropdown
  
  before_validation_on_create :set_autogenerated_attributes
  
  def sounzmedia_format
    if !format_id.nil?
      if format_id == Format.find(:first, :conditions => ["format_desc='embedded - audio'"]).format_id || format_id == Format.find(:first, :conditions => ["format_desc='embedded - video'"]).format_id
        if !sounzmedia.starts_with?("<object") || !sounzmedia.ends_with?("</object>")
          errors.add(:sounzmedia, "The embedded format must begin and end with a \"object\" tag")
        end
      elsif Format.find(format_id).format_desc.starts_with?("internal -")
        if !internal_format 
          errors.add(:sounzmedia, "Internal file extension must be one of: .mp3, .mp4 or .flv")
        end
      elsif Format.find(format_id).format_desc.starts_with?("external -")
        if !sounzmedia.starts_with?("http://")
          errors.add(:sounzmedia, "External format must begin with \"http://\"")
        end
      end
    end
  end
   
  def internal_format
      return sounzmedia.ends_with?(".mp3") || sounzmedia.ends_with?(".mp4") || sounzmedia.ends_with?(".flv") || sounzmedia.blank?
  end

  def set_autogenerated_attributes
    # set sale/loan products ids
    # we are wrapping the queries into uncached block as starting from Rails 2.0 all identical db requests are cached by default
    Resource.uncached do
      self.sale_product_id = ActiveRecord::Base.connection.select_one("SELECT NEXTVAL('sounz_product_id_seq')")['nextval'].to_i
      self.loan_product_id = ActiveRecord::Base.connection.select_one("SELECT NEXTVAL('sounz_product_id_seq')")['nextval'].to_i
      # get next value for resource_code
      self.resource_code = ActiveRecord::Base.connection.select_one("SELECT NEXTVAL('seq_resource_code')")['nextval'].to_i
    end
  end

  def frbr_type
    "resource"
  end

  def frbr_id
  resource_id
  end

  def frbr_ui_desc
  resource_title
  end
  
  #These methods are used when rendering lists of FRBR objects, e.g. a composers writings
  #The naming needs to be common to maintain a single partial for list rendering
  def frbr_list_title
    resource_title
  end
  
  def frbr_list_description
    ""
  end
  

  def frbr_relationships
    frbr_relationships=Array.new()
    for rel in relationships.uniq
      reltype=RelationshipType.find(rel.relationship_type_id)

      #Choose the entity_type that does not match this one.
      #Where both are the same, it does not matter which we pick
      my_entity=rel.ent_entity_type
      if rel.ent_entity_type == frbr_type() then 
        my_entity=rel.entity_type 
      end

      related_objects=eval('rel.'+my_entity+'s')

      for related_object in related_objects
        if rel.entity_type == rel.ent_entity_type then
          if related_object.frbr_id != frbr_id then
            frbr_relationships.push(FrbrRelationship.new(related_object,reltype.relationship_type_desc,my_entity))
          end
        else 
        frbr_relationships.push(FrbrRelationship.new(related_object,reltype.relationship_type_desc,my_entity))
        end
      end
    end
  frbr_relationships
  end
  
  
  #Helper method to get all of the formats that can be associated with a resource
  def self.all_valid_formats
    Format.find(:all, :conditions => ["resource_format = ?",true], :order => 'format_desc')
  end
  
  def self.all_resource_types
    ResourceType.find(:all,  :order => 'resource_type_desc')
  end
  
  def validate
    if !publication_year.blank?
      errors.add(:publication_year, "must be after 1839") if publication_year < 1840
      errors.add(:publication_year, "must not be more than year into the future") if publication_year > (Time.now.year+1)
    end
  end
  
  def is_a_sounzmedia?
     resource_type_sounzmedia = ResourceType.find(:first, :conditions => ["resource_type_desc = 'Media on Demand'"])
     resource_type.resource_type_id == resource_type_sounzmedia.resource_type_id
  end
  
  def is_a_sounzmedia_audio?
    resource_format_audio = Format.find(:all, :conditions => { :format_desc => ["internal - audio", "external - audio", "embedded - audio" ] })
    for format in resource_format_audio
      if format.format_id.to_s == format_id.to_s
        return true
      end
    end
    return false
  end
  
  def is_a_sounzmedia_video?
    resource_format_video = Format.find(:all, :conditions => { :format_desc => ["internal - video", "external - video", "embedded - video"] })
    for format in resource_format_video
      if format.format_id.to_s == format_id.to_s
        return true
      end
    end
    return false
  end
    
    
  def is_embedded?
    embedded_formats = Format.find(:all, :conditions => ["format_desc LIKE ? ", "%embedded%"])
    for format in embedded_formats
      if format.format_id.to_s == format_id.to_s
        return true
      end
    end
    return false
  end
    
  def publication_year_or_zero
    result = 0
    result = publication_year.to_i if !publication_year.blank?
    result
  end
    
   #-- methods to escape SOLR fields --
   def status_for_solr
     return status_id
   end
      
   def author_note_for_solr
     return FinderHelper.strip(author_note)
   end
     
   def general_note_for_solr
     return FinderHelper.strip(general_note)
   end

   def internal_note_for_solr
     return FinderHelper.strip(internal_note)
   end
    
   def dedication_note_for_solr
     return FinderHelper.strip(dedication_note)
   end

   def publisher_note_for_solr
     return FinderHelper.strip(publisher_note)
   end
   
   def publication_year_for_solr
     return FinderHelper.strip(publication_year)
   end
   
   def created_at_for_solr
     return FinderHelper.date_for_solr_ymd(created_at)
   end

   def isbn_for_solr
     return FinderHelper.strip(isbn)
   end

   def ismn_for_solr
     return FinderHelper.strip(ismn)
   end

   def isrc_for_solr
     return FinderHelper.strip(isrc)
   end

   def imprint_for_solr
     return FinderHelper.strip(imprint)
   end

   def frbr_ui_desc_for_solr
     return FinderHelper.strip(frbr_ui_desc)
   end
      
   #Override the table_name_field thing, grumble
   def code_for_solr
     return FinderHelper.strip(resource_code)
   end
      
   def title_for_solr
     return FinderHelper.strip(resource_title)
   end
      
   def title_as_string_for_solr
     return FinderHelper.strip(resource_title.downcase)
   end
      
   def authors_cvs_as_string_for_solr
     return FinderHelper.strip(author_note.downcase).gsub(' ', '')
   end
      
   def series_title_for_solr
     return FinderHelper.strip(series_title)
   end
     
   def duration_for_solr
     duration_i =-1
     if !duration.blank?
       elements = duration.split(':')
       if !elements.blank?
         seconds = (elements[0].to_i*60*60)+elements[1].to_i*60+elements[2].to_i
         duration_i = seconds
       end  
     end
     return duration_i.to_i
   end
      
   def downloadable_for_solr
     result = "no"
     result = "yes" if downloadable == true
     result
   end
    
   def type_for_solr
    return resource_type_id  
   end
   
   # Concept solr fields -------------------------
   def genres_for_solr
     concepts_as_parent(concept_genres)
   end
      
   def influences_for_solr
     concepts_as_parent(concept_influences)
   end
      
   def themes_for_solr
     concepts_as_parent(concept_themes)
   end

   # From a given list of concepts only include the parents, and uniqueify them
   def concepts_as_parent(all_concepts)
     result = []
     for c in all_concepts
       # Add the most parental id, ie not sub concepts
       if c.has_parent?
         result << c.parent.concept_id
       else
         result << c.concept_id
       end
     end
     result.uniq.sort.join(', ')
   end
      
   # 'is_related_to' relationship with resources for solr 
   def has_related_resources_for_solr
     related_resources.blank? ? 0 : 1
   end
    
   def related_resource_type_ids_for_solr
     related_resources.collect{ |r| r.resource_type_id}.join(',')
   end
      
   def item_type_ids_for_solr
     items.map{|i| i.item_type_id}.uniq.join(", ")
   end
    
   def freight_code_for_solr
     return FinderHelper.strip(freight_code)
   end
    
   # used in Music simple search
   def quicklink_format_for_solr
     if resource_type.resource_type_desc == 'sheet music'
       return "score"
     elsif Format.cd_and_dvd_formats.include?format.format_desc
       return "recording"
     elsif resource_type.resource_type_desc == 'education resource'
       return "education resource"
     end
   end
          
   #-- Buy, borrow, hire facets --
   def can_be_bought_for_solr
     result = "no"
     result = "yes" if available_for_sale == true
     result
   end

   #-- Buy, borrow, hire facets --
   def can_be_loaned_for_solr
     result = "no"
     result = "yes" if available_for_loan == true
     result
   end

   #-- Buy, borrow, hire facets --
   def can_be_hired_for_solr
     result = "no"
     result = "yes" if available_for_hire == true
     result
   end

   def mw_code_for_solr
     return FinderHelper.strip(mw_code)
   end

   #
   # Return id of matching resource type from facet resource types hash
   # 
   def available_as_resource_types_facet_for_solr
     FacetHelper.facet_resource_type(self)
   end
      
      #def downloadable_for_solr
      #  downloadable ? 1 : 0
      #end
      
      #def available_for_hire_for_solr
      #  available_for_hire ? 1 : 0
      #end
      
      #def available_for_sale_for_solr
      #  available_for_sale ? 1 : 0
      #end
  
  
  
      #This is required to render the New Zealand music section for events
      #Iterate through related expressions and get their works
      def all_associated_works
        results = []
        
    #works_described, superworks_described, expressions_described, manifestations_described,
    #manifestations_documented
    results = works_described + superworks_described.map{|sw| sw.works}
           
        #Now add works for the expressions
        for exp in expressions_described.flatten.uniq
           results = results + [exp.work]
        end
        
        #And now the manifestations
    #manifestations = manifestations_described + manifestations_documented
    #    for man in manifestations
    #      for exp in man.expressions
    #        results = results + [exp.work]
    #      end
    #    end


        results.flatten.uniq.sort_by{|w|[w.work_title.downcase]}

      end
      
      
      def all_associated_concepts
        result = concept_influences + concept_genres + concept_themes
        result.flatten.uniq.sort_by{|c| c.frbr_ui_desc}
      end
    
    def all_associated_roles
      results = []
    
    # describes, released_by, recorded_by
    results = recorders + roles_described
    
    results.flatten.uniq.sort_by{|r|[r.contributor_names]}
    end
 
  
  def all_associated_manifestations
    manifs = manifestations_described + manifestations_documented
    return manifs
  end
  
      def all_associated_resources
      results = []
          
    # describes, released_by, recorded_by
    results = related_resources + resources_described + descriptive_resources
        
    results.flatten.uniq.sort_by{|r|[r.resource_title.downcase]}        
      end	 
      
      def available_as_top_level_facet_for_solr
        "resources"
      end
      
      
    # We count items that are not in borrowed_items
    # since as per WR#51184 an item can be reserved
    # but not set out_on_loan_or_hire - needed for ERP
      def loan_items_count   
      loan_items=[]
    for item in items
      logger.debug("CHECKING ITEM #{item.id} #{item.item_type.item_type_desc.to_s}")
      if item.item_type == ItemType::RESOURCE_LIBRARY_ITEM && (item.borrowed_items.select{|bi| bi.active == true }.length < 1)
      loan_items << item
      end
    end
    logger.debug("LOAN ITEMS: #{loan_items.length}")
    return loan_items.length
      end



      def on_loan_items_count
        items.count(:all, :conditions => ["item_type_id = ? and out_on_loan_or_hire = true",
         ItemType::RESOURCE_LIBRARY_ITEM.item_type_id])
         
      end
      
      def sale_items_count
        items.count(:all, :conditions => ["item_type_id = ?",
          ItemType::SALE_ITEM.item_type_id])
          
      end
      
      def create_moneyworks_file
        filename="Product_#{DateTime::now().strftime('%Y-%m-%d')}_#{resource_id}.csv"
        filepath=Setting.get_value('MONEYWORKS_EXPORT_FOLDER')
  
        logger.debug("MONEYWORKS: CREATING MONEYWORKS FILENAME: #{filepath}/#{filename}")
        File.open("#{filepath}/#{filename}", "wb") do |f| 
        f.write("#{mw_code},#{frbr_ui_desc},#{freight_code},#{item_cost}\n")
        end
      end
    
    def is_recording?
      result = false
      
    if ['CD Rom', 'CD', 'DAT', 'video', 'podcast', 'DVD', 'cassette', 'digital sound file'].include?format.format_desc
      result = true
      end
    return result
    end
    
    def duration_human_readable
    result = ""
    if  !duration.blank?
      result = TimeHelper.convert_duration_to_hours_and_minutes(duration)
    end
    result
    end	  
    
end
