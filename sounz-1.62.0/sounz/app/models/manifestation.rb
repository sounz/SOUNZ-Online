class Manifestation < ActiveRecord::Base
    include FrbrHelper
    include FrbrMethodsManifestation
    
    validates_format_of :duration, 
                        :if => Proc.new {|manifestation| ( manifestation.duration != nil) },
                        :with => DURATION_REGEX,
                        :message=> "must be of the format |number|:|00 to 59|:|00 to 59|"
                        
                        
    
    set_primary_key "manifestation_id" 
    set_sequence_name "manifestations_manifestation_id_seq" 
    belongs_to :status
    has_many :manifestation_relationships
    has_many :relationships, 
      :through => :manifestation_relationships, 
      :select => "manifestation_relationships.relationship_type_id, relationships.*",
      :dependent => :destroy

    has_many :samples, :dependent => :destroy
    
    has_many :manifestation_access_rights


    #relationship to format
    belongs_to :format
    
    #relationship to manifestation type
    belongs_to :manifestation_type
    
    has_many :items, :dependent => :destroy
    
    has_many :expression_manifestations, :dependent => :destroy
    has_many :expressions, :through => :expression_manifestations
    
    has_many :manifestation_attachments, :dependent => :destroy
    has_many :media_items, :through => :manifestation_attachments
    
    has_many :exam_set_works
    
    #Updated by relationship 
    validates_presence_of :login_updated_by
    #validates_associated :login_updated_by

    belongs_to :login_updated_by, 
              :class_name => 'Login',
              :foreign_key => :updated_by
              
    validates_presence_of :manifestation_title, :status_id, :format, :manifestation_type
    validates_associated :format, :manifestation_type
    
    before_validation_on_create :set_autogenerated_attributes
   
    def set_autogenerated_attributes
      # set sale/loan products ids
      # we are wrapping the queries into uncached block as starting from Rails 2.0 all identical db requests are cached by default
      Manifestation.uncached do
        self.sale_product_id = ActiveRecord::Base.connection.select_one("SELECT NEXTVAL('sounz_product_id_seq')")['nextval'].to_i
        self.loan_product_id = ActiveRecord::Base.connection.select_one("SELECT NEXTVAL('sounz_product_id_seq')")['nextval'].to_i
      end
      # get next value for manifestation_code
      self.manifestation_code = ActiveRecord::Base.connection.select_one("SELECT NEXTVAL('seq_manifestation_code')")['nextval'].to_i        
    end

    # for searching manifestations
    acts_as_solr  :fields =>[
      :frbr_ui_desc_for_solr,
      :title_for_solr,
     {:title_as_string_for_solr => :string},
      :general_note_for_solr,
      :internal_note_for_solr,
      :dedication_note_for_solr,
      :publisher_note_for_solr,
      :isbn_for_solr,
      :ismn_for_solr,
      :isrc_for_solr,
      :publication_year_for_solr,
      :imprint_for_solr, 
      :mw_code_for_solr,
      :code_for_solr,
      :series_title_for_solr, 
      :downloadable_for_solr,
      :status_for_solr,
      :can_be_bought_for_solr,
      :can_be_loaned_for_solr,
      :can_be_hired_for_solr,
      :quicklink_format_for_solr,
      :item_type_ids_for_solr,
      :type_for_solr,
      :freight_code_for_solr,
     {:created_at_for_solr => :string}
      ]
      
   
    # for HTML interface
    acts_as_dropdown 
    
    def validate
      if !publication_year.blank?
        errors.add(:publication_year, "must be after 1839") if publication_year.to_i < 1840
        errors.add(:publication_year, "must not be more than year into the future") if publication_year.to_i > (Time.now.year+1)
      end
      
      if !format_id.nil?
        if format_id == Format.find(:first, :conditions => ["format_desc='embedded - audio'"]).format_id || format_id == Format.find(:first, :conditions => ["format_desc='embedded - video'"]).format_id
          if !sounzmedia.starts_with?("<object") || !sounzmedia.ends_with?("</object>")
            errors.add(:sounzmedia, "The embedded format must begin and end with a \"object\" tag")
          end
        elsif Format.find(format_id).format_desc.starts_with?("internal -")
          if !internal_format 
            errors.add(:sounzmedia, "Internal file extension must be one of: .mp3, .mp4 or .flv")
          end
        elsif Format.find(format_id).format_desc.starts_with?("external -")
          if !sounzmedia.starts_with?("http://")
            errors.add(:sounzmedia, "External format must begin with \"http://\"")
          end
        end
      end
    end
    
    def internal_format
      return sounzmedia.ends_with?(".mp3") || sounzmedia.ends_with?(".mp4") || sounzmedia.ends_with?(".flv") || sounzmedia.blank?
    end

    def frbr_type
      "manifestation"
    end

    def frbr_id
    manifestation_id
    end

    def frbr_ui_desc
      return manifestation_title
    end
    
    def frbr_ui_desc_for_solr
      return FinderHelper.strip(frbr_ui_desc)
    end
    
    
    #These methods are used when rendering lists of FRBR objects, e.g. a composers writings
    #The naming needs to be common to maintain a single partial for list rendering
    def frbr_list_title
      manifestation_title
    end

    def frbr_list_description
      general_note
    end
    

    #TODO: FIXME: should really subclass frbr_object types from a class that defines this method once.
    def frbr_relationships
      frbr_relationships=Array.new()
      for rel in relationships.uniq
        reltype=RelationshipType.find(rel.relationship_type_id)
        
        #Choose the entity_type that does not match this one.
        #Where both are the same, it does not matter which we pick
        my_entity=EntityType.entityTypeToId(rel.ent_entity_type_id)
        if EntityType.entityTypeToId(rel.ent_entity_type_id) == frbr_type() then 
          my_entity= EntityType.entityTypeToId(rel.entity_type_id)
        end
        
        related_objects=eval('rel.'+my_entity+'s')
        
        for related_object in related_objects
          if rel.entity_type_id == rel.ent_entity_type_id then
            if related_object.id != id then
              frbr_relationships.push(FrbrRelationship.new(related_object,reltype.relationship_type_desc,my_entity))
            end
          else 
          frbr_relationships.push(FrbrRelationship.new(related_object,reltype.relationship_type_desc,my_entity))
          end
        end
      end
    frbr_relationships
    end


    #Grab hold of the thumbnails
    def thumbnails
      manifestation_attachments.reject{|a| a.attachment_type_id != 4}
    end

    #Grab hold of hte images
    def images
      manifestation_attachments.reject{|a| a.attachment_type_id != 3}
    end


    # Is this manifestation a score?
    def is_a_score?
      manifestation_type.manifestation_type_category == 1
    end

    # Is this manifestation a sounzmedia?
    def is_a_sounzmedia?
      manifestation_type_sounzmedia = ManifestationType.find(:first, :conditions => ["manifestation_type_desc = 'Media on Demand'"])
      manifestation_type.manifestation_type_id == manifestation_type_sounzmedia.manifestation_type_id
    end
    
    def is_a_sounzmedia_audio?
      manifestation_format_audio = Format.find(:all, :conditions => { :format_desc => ["internal - audio", "external - audio", "embedded - audio" ] })
#      logger.debug "MANIF " + format_id.to_s
      for format in manifestation_format_audio
        if format.format_id.to_s == format_id.to_s
          return true
        end
      end
      return false
    end
    
    def is_a_sounzmedia_video?
      manifestation_format_video = Format.find(:all, :conditions => { :format_desc => ["internal - video", "external - video", "embedded - video"] })
      for format in manifestation_format_video
        if format.format_id.to_s == format_id.to_s
          return true
        end
      end
      return false
    end
    
    def is_embedded?
      embedded_formats = Format.find(:all, :conditions => ["format_desc LIKE ? ", "%embedded%"])
      for format in embedded_formats
        if format.format_id.to_s == format_id.to_s
          return true
        end
      end
      return false
    end
    
    #Is this manifestation a recording?
    def is_a_recording?
      manifestation_type.manifestation_type_category == 2
    end

    #This has not been defined, but include it for sake of completeness
    def is_an_other?
      manifestation_type.manifestation_type_category == 3
    end
    
    #This is used to render the view of a manifstation
    def type_category_string
      result = "Manifestation"
      result = "Score" if is_a_score?
      result = "Recording" if is_a_recording?
      result = "Media on Demand" if is_a_sounzmedia?
      result
    end

    #Add samples to this manifestation
    def add_sample(sample)
      samples << sample
    end
    
=begin
m = Manifestation.find(5834)
es = Expression.find(:all, :limit => 10)
m.add_expressions(es)
=end
    
    #Add an array of expressions to this manifestation - note this may have to change due to possibly
    #chagned nature of requirements (ie tracks being manifestations)
    def add_expressions(expressions)
      puts "Expressions class is #{expressions.class}"
      begin
        transaction do
          for expression in expressions
            puts "Expression class is #{expression.class}"
            puts "Adding expression #{expression.expression_id} to manifestation #{self.manifestation_id}"
            raise if !add_expression(expression)
            puts "Added expression #{expression.expression_id}"
          end
        end
      rescue 
        puts "TRAN FAILED"
 
        return false
      end
      return true
    end
    
    #Add an expression to this manifestation - this does the following:
    #* Save the manifestation checking for errors
    #* If this works, add an entry into the expressions_manifestation table
    #* Add a FRBR entry - expression is embodied in a manifestation
    def add_expression(expression)
      puts "Adding expression #{expression} to manifestation"
      if expression.blank?
        raise ArgumentError, "Expression cannot be nil"
      end
      
      
    begin
        transaction do
          #Save the current manifestation (self) as we need an id
          raise  if !self.save
          logger.debug "DEBUG: Saved manifestation"
          
          #Ditto the expression - the joy of has many through
          logger.debug "DEBUG: **** Trying to save expression.. is it nil? #{expression == nil}"
          
          logger.debug "DEBUG: Pre save, "
          expression_saved = expression.save

          logger.debug "DEBUG: Expression has been saved"
          raise ArgumentError if !expression_saved
          logger.debug "DEBUG: Saved expression"
          
          #We have both ends of the expression and manifestation saved, so now can create the join
          logger.debug "DEBUG: Creating join"
          em = ExpressionManifestation::new
          logger.debug "DEBUG: Assigning manif"
          em.manifestation = self
          
          logger.debug "DEBUG: Assigning expression"
          em.expression = expression
          
          logger.debug "DEBUG: Saving join"
          join_saved = em.save
          logger.debug em.to_yaml
          
          raise TransactionError  if !join_saved
          
          logger.debug "DEBUG: Saved join"
          
          #Right, now we have the FRBR bit to do!
          logger.debug "DEBUG: FRBR TIME...."
      
          raise if !RelationshipHelper.add_frbr_relationship(:manifestation, self.manifestation_id, :is_the_embodiment_of, 
          :expression, expression.expression_id, self.updated_by )
    
          logger.debug "DEBUG: Saved FRBR"
          
        end
        
      rescue Exception => e
      logger.error "DEBUG: Transaction failed" + e.message
        #Code errored out, indicate this by a false flag
        return false
      end
      
      #We got this far, everything is saved
      return true
    end
    
    
    #Delete an expression from this manifestation
    def remove_expression(expression)
      
    end
    
    
    #This is used for sorting in manifestatio helper, and avoid a nil pointer exception
    #Returns either the publication year or zero if its nil
    def publication_year_or_zero
      result = 0
      result = publication_year.to_i if !publication_year.blank?
      result
    end
    
    
    
    
    #---------------------------------------------------------------------------------------------
     #- Save the expression and also update the FRBR relationships for the expression to the work -
     #---------------------------------------------------------------------------------------------
     def save_with_frbr
       logger.debug "Saving with frbr for work"
      begin
        transaction do
          logger.debug "**TRACE1**"
          save! #This will throw an exception if it fails
      logger.debug "**TRACE2 expression has id #{self.expression_id}**"
          update_frbr_for_expression_work_relationship(self.updated_by) #This also throws an exception if it fails
          logger.debug "**TRACE3 - relationship added"
         end
      rescue Exception => e
          logger.debug "Exception: #{e.class}: #{e.message}\n\t#{e.backtrace.join("\n\t")}"

         logger.debug "**TRACE4**"
         return false
      end

       logger.debug "TRACEDONE"
       #Got this far so all good
      return true
     end


#========================================================================

     #----------------------------------------------------------------------------------------------------
     #- Update the attributes of the expression from an update, and fix the FRBR relationships if needbe -
     #----------------------------------------------------------------------------------------------------
     def update_attributes_with_frbr(parameters, login)
       begin
         transaction do
           logger.debug "** UPDATING PARAMS FOR EXPRESSION FROM FORM **"
           raise if !update_attributes(parameters) 
           logger.debug "Expression work is #{self.work.work_title}"
           update_frbr_for_expression_work_relationship(login)
           #Got this far so all good
           return true
         end
        rescue
          return false
        end
     end


     #- Update the FRBR association for expression to work by doing the following -
     #  * Delete any existing expression to work links
     #  * Add the new one (that for expression.work) - in effect "expression is realisation_of expression.work"
     def update_frbr_for_expression_work_relationship(login)
       RelationshipHelper.delete_all_frbr_relationships(:expression, self.expression_id, :is_realisation_of) 
       raise if !RelationshipHelper.add_frbr_relationship(:expression, self.expression_id, :is_realisation_of, 
          :work, self.work.work_id, login )
     end
    
    
      #-- methods to escape SOLR fields --
      def created_at_for_solr
        return FinderHelper.date_for_solr_ymd(created_at)
      end

      def publication_year_for_solr
        FinderHelper.strip(publication_year)
      end

      def mw_code_for_solr
        FinderHelper.strip(mw_code)
      end

      def general_note_for_solr
        return FinderHelper.strip(general_note)
      end

    def internal_note_for_solr
      return FinderHelper.strip(internal_note)
    end

      def dedication_note_for_solr
        return FinderHelper.strip(dedication_note)
      end


      def publisher_note_for_solr
        return FinderHelper.strip(publisher_note)
      end


      def isbn_for_solr
        return FinderHelper.strip(isbn)
      end


      def ismn_for_solr
        return FinderHelper.strip(ismn)
      end


      def isrc_for_solr
        return FinderHelper.strip(isrc)
      end		      


      def imprint_for_solr
        return FinderHelper.strip(imprint)
      end


      def frbr_ui_desc_for_solr
        return FinderHelper.strip(frbr_ui_desc)
      end
      
    def series_title_for_solr
    return FinderHelper.strip(series_title)
    end      
      
    #Override the table_name_field thing, grumble
      def code_for_solr
        return FinderHelper.strip(manifestation_code)
      end
      
      def title_for_solr
        return FinderHelper.strip(manifestation_title)
      end
    
    def title_as_string_for_solr
    return FinderHelper.strip(manifestation_title)
    end	  
    
    def downloadable_for_solr
      result = "no"
    result = "yes" if downloadable == true
    result
    end	  
      
    def status_for_solr
    return status_id
    end
    
    def item_type_ids_for_solr
    items.map{|i| i.item_type_id}.uniq.join(", ")
    end
    
    def type_for_solr
      return manifestation_type_id
    end
    
    def freight_code_for_solr
      return FinderHelper.strip(freight_code)
    end	  
      
    # used in Music simple search
    def quicklink_format_for_solr
      if Format.score_formats.include?format.format_desc
        return "score"
      elsif Format.cd_and_dvd_formats.include?format.format_desc
        return "recording"	    	
      end
    end
    
      #-- Buy, borrow, hire facets --
      def can_be_bought_for_solr
        result = "no"
        result = "yes" if available_for_sale == true
        result
      end

      #-- Buy, borrow, hire facets --
      def can_be_loaned_for_solr
        result = "no"
        result = "yes" if available_for_loan == true
        result
      end

      #-- Buy, borrow, hire facets --
      def can_be_hired_for_solr
        result = "no"
        result = "yes" if available_for_hire == true
        result
      end
    
    # We count items that are not in borrowed_items
    # since as per WR#51184 an item can be reserved
    # but not set out_on_loan_or_hire - needed for ERP
    def loan_items_count
        loan_items=[]
        for item in items
          logger.debug("CHECKING ITEM #{item.id} #{item.item_type.item_type_desc.to_s}")
          if item.item_type == ItemType::MUSIC_LIBRARY_ITEM && (item.borrowed_items.select{|bi| bi.active == true }.length < 1)
            loan_items << item
          end
        end
        logger.debug("LOAN ITEMS: #{loan_items.length}")
        return loan_items.length
      end

      def on_loan_items_count
        onloan_items=[]
        for item in items
          logger.debug("CHECKING ITEM #{item.id}")
          if item.item_type.item_type_desc.to_s=='Music library item' && (item.out_on_loan_or_hire == true)
            onloan_items << item
          end
        end
      logger.debug("LOAN ITEMS: #{onloan_items.length}")
      return onloan_items.length
      end
      
      def sale_items_count
      sale_items=[]
        for item in items
          if item.item_type.item_type_desc.to_s=='Sale item'
            sale_items << item
          end
        end
      logger.debug("SALE ITEMS: #{sale_items.length}")
      return sale_items.length
      end
    
    
    
    #-- convenience methods used for rendering views of manifestations --
=begin

 def all_works
    result = []
    for exp in (happening_expressions+presented_expressions).flatten.uniq
     # result << exp.work
    # logger.debug "CLASS:#{exp.work.class}"
     result = result + [exp.work]
    end
    
    
    result.flatten.uniq.sort_by{|w|[w.work_title]}

  end
=end



  #This is a list of all the performers of expressions associated with this manifestation - it appears
  #in the featuring section of the page
  def performers_of_expressions
    performers = expressions.map{|e| e.performers}
    performers.flatten.uniq.sort_by{|r| r.contributor_names} 
  end
  
  #Find all the supporters of a manifestation
  def all_publishers
    result = recorders+publishers
    result.flatten.uniq.sort_by{|role|[role.contributor_names]}
  end

def create_moneyworks_file
        filename="Product_#{DateTime::now().strftime('%Y-%m-%d')}_#{manifestation_id}.csv"
        filepath=Setting.get_value('MONEYWORKS_EXPORT_FOLDER')
  
        logger.debug("MONEYWORKS: CREATING MONEYWORKS FILENAME: #{filepath}/#{filename}")
        File.open("#{filepath}/#{filename}", "wb") do |f| 
          f.write("#{mw_code},#{frbr_ui_desc},#{freight_code},#{item_cost}\n")
        end
end

  #
  # Return related works
  #
  def related_works
    works = []
    expressions.each do |e|
      works.push(e.work)
    end    	
    return works
  end

end
