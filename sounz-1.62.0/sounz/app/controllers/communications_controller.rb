class CommunicationsController < ApplicationController
  include ApplicationHelper
  
  def index
    list
    render :action => 'list'
  end

  # GETs should be safe (see http://www.w3.org/2001/tag/doc/whenToUseGet.html)
  verify :method => :post, :only => [ :destroy, :create, :update ],
         :redirect_to => { :action => :list }

  def list
    @communications = Communication.paginate(:page => params[:page], :per_page => 10)
  end

  #--------------------------------------
  #- Prepare/display communication list -
  #- for a person or organisation based -
  #- on params                          -
  #--------------------------------------
  def entity_communication_list
    # get person/organisation from params
    @from = params[:from]
    
    # person case
    if @from.match('person')
      @person = Person.find(params[:id])
      @entity = @person
      @page_title = "#{@entity.full_name}'s" 
    end
    
    # organisation case
    if @from.match('organisation')
      @organisation = Organisation.find(params[:id])
      @entity = @organisation
      @page_title = "#{@entity.organisation_name}'s"
    end
    
    # requested communication status
    status = params[:status]
    if status.blank? || status.match('o') 
      # open communications
      @communication_status = Communication.statuses[:open]
      @page_title = @page_title + " Open Communications"
    elsif status.match('c')
      # closed communications
      @communication_status = Communication.statuses[:closed]
      @page_title = @page_title + " Closed Communications"
    else
      @communication_status = Communication.statuses[:open]
      @page_title = @page_title + " Open Communications"
    end
    
    role_id_list=""
    
    # role ids
    @entity.roles.map{|r|role_id_list+=r.role_id.to_s+"," }
    
    # find communications that match all criteria
    @communications = Communication.find(
          :all, :include => :role, 
          :conditions => ["roles.role_id IN (?) and communications.status = ?", @entity.roles, @communication_status], 
          :order => 'communications.created_at desc')
    
  end
    
  # method generated by scaffolding
  def show
    @communication = Communication.find(params[:id])
  end

  # ---------------------------------------------
  # - New communication - show the initial form -
  # ---------------------------------------------
  def new
      
    # get person/organisation from params
    @from = params[:from]
    @person = Person.find(params[:id]) if @from.match('person')
    @organisation = Organisation.find(params[:id]) if @from.match('organisation')
        
    @role_id = nil
    @status_text = Communication.statuses[:open]
    @communication = Communication.new
    @communication.created_at = Time.now # default value required for interface
    
    @communication = Communication.new
  end

  # ----------------------------
  # - Create new communication -
  # ----------------------------
  def create
    @from = params[:from]
    
    if @from.match('person')
      @person = Person.find(params[:id])
      id = @person.person_id
    end
    
    if @from.match('organisation')
      @organisation = Organisation.find(params[:id])
      id = @organisation.organisation_id 
    end
        
    # If the form was submitted properly, deal with it
    if params[:communication]
      start_date_ok = false
      begin
        convert_datetime_to_db_format_in_params(params, 'communication','created_at')
        start_date_ok = true
      rescue TimeParseException
        @communication.errors.add("Start time")
      end
      
      closed_date_ok = false
      begin
        convert_datetime_to_db_format_in_params(params, 'communication','closed_at')
        closed_date_ok = true
      rescue TimeParseException
        @communication.errors.add("Closing time")
      end
      
      @communication = Communication.new(params[:communication])
      
      # updated by
      @communication.updated_by = get_user.login_id
      
      if @communication.save
        flash[:notice] = 'Communication was successfully created.'
        redirect_to :action => 'edit', :id => id, :from => @from, :communication => @communication
      else
        render :action => 'new', :id => id, :from => @from
      end
    end
  end
  
  # ---------------------------
  # - Edit communication mode -
  # ---------------------------  
  def edit
    @from = params[:from]
    @person = Person.find(params[:id]) if @from.match('person')
    @organisation = Organisation.find(params[:id]) if @from.match('organisation')
        
    @communication = Communication.find(params[:communication])
    @role = @communication.role
	@status_text = get_key_for_value(@communication.status, Communication.statuses)
  end

  # ------------------------
  # - Update communication -
  # ------------------------
  def update
    @from = params[:from]
    
    if @from.match('person')
      @person = Person.find(params[:id])
      id = @person.person_id
    end
    
    if @from.match('organisation')
      @organisation = Organisation.find(params[:id])
      id = @organisation.organisation_id  
    end
    
    @communication = Communication.find(params[:communication_id])
    
    # updated by
    @communication.updated_by = get_user.login_id
    
	params[:communication][:closed_at] = '' if params[:communication][:status] == 'o'
	
    # If the form was submitted properly, deal with it
    if params[:communication]
      start_date_ok = false
      begin
        convert_datetime_to_db_format_in_params(params, 'communication','created_at')
        start_date_ok = true
      rescue TimeParseException
        @communication.errors.add("Start time")
      end
      
      closed_date_ok = false
      begin
        convert_datetime_to_db_format_in_params(params, 'communication','closed_at')
        closed_date_ok = true
      rescue TimeParseException
        @communication.errors.add("Closing time")
      end
      	  
      if @communication.update_attributes(params[:communication])
	    
        flash[:notice] = 'Communication was successfully updated.'
        redirect_to :action => 'edit', :id => id, :from => @from, :communication => @communication
      else
        render :action => 'edit', :id => id, :from => @from, :communication => @communication
      end
    end
  end

  # method generated by scaffold
  # FIXME currently deletion of a communication is
  # not implemented, do we need to delete communications? 
  def destroy
    Communication.find(params[:id]).destroy
    redirect_to :action => 'list'
  end
  
  #------------------
  # When a role is selected for a communication, the following happen in the interface
  # <ul>
  # <li>The organisation name is changed to reflect the chosen role</li>
  # </ul>
  #------------------
  def communication_role_selected
    #show_params(params)
    role_id = params[:role_id]
    
    @from = params[:from]
    
    @organisation_value = "No role chosen"
    @person_value = "No role chosen"
    
    if !role_id.blank?
      @new_role = Role.find(role_id)
      
      #check if person exists
      if !@new_role.person.blank?
        @person_value = @new_role.person.full_name
      else
        @person_value = "No person associated with this role"
      end
      
      #check if organisation exists
      if !@new_role.organisation.blank?
        @organisation_value = @new_role.organisation.organisation_name
      else
        @organisation_value = "No organisation associated with this role"
      end
    end
    
    render :layout => false
    
  end
  
  #------------------
  # When a status is selected for a communication, the following happen in the interface
  # <ul>
  # <li>The closing date is shown if the status is set to closed</li>
  # </ul>
  #------------------
  def communication_status_selected
    @new_status_text = get_key_for_value(params[:status_code], Communication.statuses)
    comm_id = params[:comm_id]
    
    #If this is a new communication being added, 
    if comm_id == nil
      render(:partial => "communication_closed_date_field", 
      :locals => { :status => @new_status_text, :closed_at => Time.now, :disabled => false}, :layout => false)
    else
      @communication = Communication.find(comm_id)
      render(:partial => "communication_closed_date_field", 
      :locals => { :status => @new_status_text, :closed_at => @communication.closed_at, :disabled => false}, :layout => false)
    end
  end
  
end
